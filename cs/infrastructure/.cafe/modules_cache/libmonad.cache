{"module":{"name":"libmonad","deps":[],"adaptor":{"type":"csmodule"}},"source":{"sources":[{"filename":"index","source":"(function() {\n  var SEX, cont_m, cont_maybe, cont_t, domonad, drop_while, e1, e2, e3, f1, f2, f3, first, identity, identity_m, is_function, is_null, is_sex, lift_async, lift_sync, lift_sync1, log_result, maybe_m, run, say, u, y;\n  var __slice = Array.prototype.slice;\n\n  identity = function(x) {\n    return x;\n  };\n\n  first = function(s) {\n    return s[0];\n  };\n\n  drop_while = function(f, s) {\n    var i, _i, _len;\n    for (_i = 0, _len = s.length; _i < _len; _i++) {\n      i = s[_i];\n      if (!(f(i))) return i;\n    }\n  };\n\n  is_null = function() {\n    var v;\n    v = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    if (v.length === 0) {\n      return null;\n    } else {\n      return v[0] === null;\n    }\n  };\n\n  is_function = function(v) {\n    return typeof v === 'function';\n  };\n\n  domonad = function(_arg, functions, init_value) {\n    var bind, f0, result;\n    result = _arg.result, bind = _arg.bind;\n    f0 = bind(result(init_value), functions[0]);\n    return ([f0].concat(functions.slice(1))).reduce(function(a, b) {\n      return bind(a, b);\n    });\n  };\n\n  identity_m = function() {\n    return {\n      result: identity,\n      bind: function(mv, f) {\n        return f(mv);\n      }\n    };\n  };\n\n  maybe_m = function(_arg) {\n    var is_error;\n    is_error = _arg.is_error;\n    return {\n      zero: function() {\n        return is_error();\n      },\n      result: function(v) {\n        return v;\n      },\n      bind: function(mv, f) {\n        if (is_error(mv)) {\n          return mv;\n        } else {\n          return f(mv);\n        }\n      },\n      plus: function() {\n        var mvs;\n        mvs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return first(drop_while(is_error(mvs)));\n      }\n    };\n  };\n\n  cont_m = function() {\n    return {\n      result: function(v) {\n        return function(c) {\n          return c(v);\n        };\n      },\n      bind: function(mv, f) {\n        return function(c) {\n          return mv((function(v) {\n            return (f(v))(c);\n          }));\n        };\n      }\n    };\n  };\n\n  cont_t = function(inner) {\n    return {\n      result: function(v) {\n        return function(c) {\n          return c(inner.result(v));\n        };\n      },\n      bind: function(mv, f) {\n        return function(c) {\n          var get_h;\n          get_h = function(v) {\n            var inner_bind_res;\n            inner_bind_res = inner.bind(v, f);\n            if (is_function(inner_bind_res)) {\n              return inner_bind_res;\n            } else {\n              return function(c) {\n                return c(inner_bind_res);\n              };\n            }\n          };\n          return mv((function(v) {\n            return (get_h(v))(c);\n          }));\n        };\n      }\n    };\n  };\n\n  lift_sync = function(arity, f) {\n    ' Lifts a function:\\n        f: arg1 -> ... -> argN\\nto a function:\\n        f1: (arg1 -> ... -> argN) -> cont';    return function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return function(c) {\n        var res;\n        res = f.apply(null, args.slice(0, arity));\n        return c(res);\n      };\n    };\n  };\n\n  lift_async = function(arity, f) {\n    ' Lifts a function:\\n        f: arg1 -> ... -> argN -> cb\\nto a function:\\n        f1: (arg1 -> ... argN) -> cont';    return function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return function(c) {\n        return f.apply(null, args.slice(0, (arity - 1)).concat([c]));\n      };\n    };\n  };\n\n  module.exports = {\n    domonad: domonad,\n    identity_m: identity_m,\n    maybe_m: maybe_m,\n    cont_m: cont_m,\n    cont_t: cont_t,\n    lift_sync: lift_sync,\n    lift_async: lift_async,\n    is_null: is_null\n  };\n\n  say = function() {\n    var m;\n    m = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return console.log.apply(console, m);\n  };\n\n  log_result = function() {\n    var x;\n    x = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return say.apply(null, x);\n  };\n\n  run = function(c) {\n    return c(log_result);\n  };\n\n  lift_sync1 = function(f, delay) {\n    return function(x) {\n      return function(c) {\n        return setTimeout(function() {\n          return c(f(x));\n        }, delay);\n      };\n    };\n  };\n\n  SEX = 'sex';\n\n  is_sex = function() {\n    var v;\n    v = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    if (v.length === 0) {\n      return SEX;\n    } else {\n      return v[0] === SEX;\n    }\n  };\n\n  e1 = function(x) {\n    say(1);\n    return x * x;\n  };\n\n  e2 = function(x) {\n    say(2);\n    x + 2;\n    return SEX;\n  };\n\n  e3 = function(x) {\n    say(3);\n    return x + 0.25;\n  };\n\n  f1 = lift_sync1(e1, 100);\n\n  f2 = lift_sync1(e2, 200);\n\n  f3 = lift_sync1(e3, 300);\n\n  y = domonad(cont_m(), [f1, f2, f3, f1], 33);\n\n  cont_maybe = cont_t(maybe_m({\n    is_error: is_sex\n  }));\n\n  u = domonad(cont_maybe, [f1, f2, f3], 33);\n\n}).call(this);\n","type":"commonjs"}],"ns":"libmonad","mod_src":"/home/eugene/github/DNA_Examples/cs/infrastructure/libmonad"}}