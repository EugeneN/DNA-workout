{"module":{"name":"libprotocol","deps":[],"adaptor":{"type":"csmodule"}},"source":{"sources":[{"filename":"index","source":"(function() {\n  var DEFAULT_PROTOCOLS, Implementations, Protocols, THIS, discover_impls, dispatch_impl, dump_impls, get_arity, get_default_protocols, get_protocol, is_async, register_protocol, register_protocol_impl, say;\n  var __slice = Array.prototype.slice;\n\n  say = function() {\n    var a;\n    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return console.log.apply(console, a);\n  };\n\n  Implementations = {};\n\n  Protocols = {};\n\n  THIS = 'this';\n\n  DEFAULT_PROTOCOLS = ['IDom', 'IMath'];\n\n  get_protocol = function(p) {\n    if (Protocols.hasOwnProperty(p)) {\n      return Protocols[p];\n    } else {\n      throw \"No such registered protocol: '\" + p + \"'\";\n    }\n  };\n\n  get_default_protocols = function() {\n    return DEFAULT_PROTOCOLS;\n  };\n\n  register_protocol = function(name, p) {\n    if (!Protocols.hasOwnProperty(p)) {\n      say(\"Registering new protocol '\" + name + \"'\");\n      return Protocols[name] = p;\n    } else {\n      throw \"Such protocol is already registered: '\" + name + \"'\";\n    }\n  };\n\n  is_async = function(ns, method_name) {\n    var args, async, m, name, _ref, _ref2;\n    m = (_ref = Protocols[ns]) != null ? _ref.filter(function(_arg) {\n      var mn;\n      mn = _arg[0];\n      return mn === method_name;\n    }) : void 0;\n    if (m) {\n      _ref2 = m[0], name = _ref2[0], args = _ref2[1], async = _ref2[2];\n      return async === 'async';\n    } else {\n      return null;\n    }\n  };\n\n  get_arity = function(ns, method_name) {\n    var argums, async, m, name, _ref, _ref2;\n    m = (_ref = Protocols[ns]) != null ? _ref.filter(function(_arg) {\n      var mn;\n      mn = _arg[0];\n      return mn === method_name;\n    }) : void 0;\n    if (m) {\n      _ref2 = m[0], name = _ref2[0], argums = _ref2[1], async = _ref2[2];\n      return argums.length;\n    } else {\n      throw \"Arity requested for unknown method \" + ns + \"/\" + method_name;\n    }\n  };\n\n  register_protocol_impl = function(protocol, impl) {\n    if (!get_protocol(protocol)) {\n      throw \"Can't register implementation for an unknown protocol: '\" + protocol + \"'\";\n    }\n    if (!Implementations.hasOwnProperty(protocol)) {\n      say(\"Registering an implementation for the protocol '\" + protocol + \"'\");\n    } else {\n      say(\"Redefining existing implementation of protocol '\" + protocol + \"'\");\n    }\n    return Implementations[protocol] = impl;\n  };\n\n  discover_impls = function() {\n    var bootstrapper, definition, exports, impl, modname, protocol, _ref, _results;\n    bootstrapper = require('bootstrapper');\n    _results = [];\n    for (modname in bootstrapper.modules) {\n      exports = require(modname);\n      if (exports.protocols && exports.protocols.definitions) {\n        _ref = exports.protocols.definitions;\n        for (protocol in _ref) {\n          definition = _ref[protocol];\n          register_protocol(protocol, definition);\n        }\n      }\n      if (exports.protocols && exports.protocols.implementations) {\n        _results.push((function() {\n          var _ref2, _results2;\n          _ref2 = exports.protocols.implementations;\n          _results2 = [];\n          for (protocol in _ref2) {\n            impl = _ref2[protocol];\n            _results2.push(register_protocol_impl(protocol, impl));\n          }\n          return _results2;\n        })());\n      } else {\n        _results.push(void 0);\n      }\n    }\n    return _results;\n  };\n\n  dispatch_impl = function() {\n    var node, protocol, rest;\n    protocol = arguments[0], node = arguments[1], rest = 3 <= arguments.length ? __slice.call(arguments, 2) : [];\n    if (!(Protocols[protocol] && Implementations[protocol])) discover_impls();\n    if (Implementations[protocol]) {\n      return Implementations[protocol](node);\n    } else {\n      return null;\n    }\n  };\n\n  dump_impls = function() {\n    return say(\"Currently registered implementations:\", Implementations);\n  };\n\n  module.exports = {\n    register_protocol_impl: register_protocol_impl,\n    register_protocol: register_protocol,\n    get_default_protocols: get_default_protocols,\n    get_protocol: get_protocol,\n    dispatch_impl: dispatch_impl,\n    dump_impls: dump_impls,\n    is_async: is_async,\n    get_arity: get_arity,\n    discover_impls: discover_impls\n  };\n\n}).call(this);\n","type":"commonjs"}],"ns":"libprotocol","mod_src":"/Users/eugene/github/DNA-workout/cs/lib/libprotocol"}}