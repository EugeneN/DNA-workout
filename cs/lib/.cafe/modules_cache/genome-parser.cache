{"module":{"name":"genome-parser","deps":[],"adaptor":{"type":"cakefile"}},"source":{"sources":[{"filename":"index","source":"/* Jison generated parser */\nvar parser = (function(){\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"program\":3,\"text\":4,\"EOF\":5,\"statement\":6,\";\":7,\"event_binding_def\":8,\"events\":9,\":\":10,\"handlers\":11,\"event_expression\":12,\",\":13,\"event\":14,\"symbol\":15,\"/\":16,\"@\":17,\"handler\":18,\"handler_expression\":19,\"|\":20,\"partially_applied_handler\":21,\"IDENTIFIER\":22,\"NUMBER\":23,\"STRING\":24,\"[\":25,\"item_list\":26,\"]\":27,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",7:\";\",10:\":\",13:\",\",16:\"/\",17:\"@\",20:\"|\",22:\"IDENTIFIER\",23:\"NUMBER\",24:\"STRING\",25:\"[\",27:\"]\"},\nproductions_: [0,[3,0],[3,2],[4,1],[4,3],[6,1],[6,1],[8,3],[9,1],[9,3],[12,1],[12,2],[14,1],[14,3],[14,3],[14,5],[11,1],[11,3],[18,1],[18,3],[19,1],[19,2],[21,1],[21,3],[21,3],[21,5],[15,1],[15,1],[15,1],[15,3],[26,0],[26,1],[26,2]],\nperformAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 2:\n           console.log($$[$0-1]);\n           return $$[$0-1];\n        \nbreak;\ncase 3: this.$ = [$$[$0]]; \nbreak;\ncase 4:\n           this.$ = ($$[$0-2]).concat($$[$0]);\n        \nbreak;\ncase 6: this.$ = $$[$0]; \nbreak;\ncase 7: this.$ = {events: $$[$0-2], handlers: $$[$0]}; \nbreak;\ncase 8: this.$ = [$$[$0]]; \nbreak;\ncase 9: this.$ = ($$[$0-2]).concat([$$[$0]]); \nbreak;\ncase 10: this.$ = [$$[$0]]; \nbreak;\ncase 11: this.$ = Array.isArray($$[$0-1]) ? ($$[$0-1]).concat([$$[$0]]) : [$$[$0-1], $$[$0]]; \nbreak;\ncase 12: this.$ = {ns: undefined, event: $$[$0], scope: undefined}; \nbreak;\ncase 13: this.$ = {ns: $$[$0-2], event: $$[$0-1], scope: undefined}; \nbreak;\ncase 14: this.$ = {ns: undefined, event: $$[$0-2], scope: $$[$0]}; \nbreak;\ncase 15: this.$ = {ns: $$[$0-4], event: $$[$0-2], scope: $$[$0]}; \nbreak;\ncase 16: this.$ = [$$[$0]]; \nbreak;\ncase 17: this.$ = ($$[$0-2]).concat([$$[$0]]); \nbreak;\ncase 18: this.$ = $$[$0]; \nbreak;\ncase 19: this.$ = Array.isArray($$[$0-2]) ? ($$[$0-2]).concat([$$[$0]]) : [$$[$0-2], $$[$0]]; \nbreak;\ncase 20: this.$ = [$$[$0]]; \nbreak;\ncase 21: this.$ = Array.isArray($$[$0-1]) ? ($$[$0-1]).concat([$$[$0]]) : [$$[$0-1], $$[$0]]; \nbreak;\ncase 22: this.$ = {ns: undefined, method: $$[$0], scope: undefined}; \nbreak;\ncase 23: this.$ = {ns: $$[$0-2], method: $$[$0], scope: undefined}; \nbreak;\ncase 24: this.$ = {ns: undefined, method: $$[$0-2], scope: $$[$0]}; \nbreak;\ncase 25: this.$ = {ns: $$[$0-4], method: $$[$0-2], scope: $$[$0]}; \nbreak;\ncase 26: this.$ = { type: \"symbol\", name: $$[$0] }; \nbreak;\ncase 27: this.$ = { type: \"number\", value: parseInt($$[$0], 10)}; \nbreak;\ncase 28: this.$ = { type: \"string\", value: ($$[$0]).match('\\\"(\\\\.|[^\\\\\"]*?)\\\"')[1] }; \nbreak;\ncase 29: this.$ = { type: \"vector\", value: $$[$0-1]}; \nbreak;\ncase 30: this.$ = []; \nbreak;\ncase 31: this.$ = [$$[$0]]; \nbreak;\ncase 32: this.$ = $$[$0-1].concat($$[$0]); \nbreak;\n}\n},\ntable: [{1:[2,1],3:1,4:2,6:3,7:[1,4],8:5,9:6,12:7,14:8,15:9,22:[1,10],23:[1,11],24:[1,12],25:[1,13]},{1:[3]},{5:[1,14],7:[1,15]},{5:[2,3],7:[2,3]},{5:[2,5],7:[2,5]},{5:[2,6],7:[2,6]},{10:[1,16],13:[1,17]},{10:[2,8],13:[2,8],14:18,15:9,22:[1,10],23:[1,11],24:[1,12],25:[1,13]},{10:[2,10],13:[2,10],22:[2,10],23:[2,10],24:[2,10],25:[2,10]},{10:[2,12],13:[2,12],16:[1,19],17:[1,20],22:[2,12],23:[2,12],24:[2,12],25:[2,12]},{5:[2,26],7:[2,26],10:[2,26],13:[2,26],16:[2,26],17:[2,26],20:[2,26],22:[2,26],23:[2,26],24:[2,26],25:[2,26],27:[2,26]},{5:[2,27],7:[2,27],10:[2,27],13:[2,27],16:[2,27],17:[2,27],20:[2,27],22:[2,27],23:[2,27],24:[2,27],25:[2,27],27:[2,27]},{5:[2,28],7:[2,28],10:[2,28],13:[2,28],16:[2,28],17:[2,28],20:[2,28],22:[2,28],23:[2,28],24:[2,28],25:[2,28],27:[2,28]},{15:22,22:[1,10],23:[1,11],24:[1,12],25:[1,13],26:21,27:[2,30]},{1:[2,2]},{6:23,7:[1,4],8:5,9:6,12:7,14:8,15:9,22:[1,10],23:[1,11],24:[1,12],25:[1,13]},{11:24,15:28,18:25,19:26,21:27,22:[1,10],23:[1,11],24:[1,12],25:[1,13]},{12:29,14:8,15:9,22:[1,10],23:[1,11],24:[1,12],25:[1,13]},{10:[2,11],13:[2,11],22:[2,11],23:[2,11],24:[2,11],25:[2,11]},{15:30,22:[1,10],23:[1,11],24:[1,12],25:[1,13]},{15:31,22:[1,10],23:[1,11],24:[1,12],25:[1,13]},{15:33,22:[1,10],23:[1,11],24:[1,12],25:[1,13],27:[1,32]},{22:[2,31],23:[2,31],24:[2,31],25:[2,31],27:[2,31]},{5:[2,4],7:[2,4]},{5:[2,7],7:[2,7],13:[1,34]},{5:[2,16],7:[2,16],13:[2,16],20:[1,35]},{5:[2,18],7:[2,18],13:[2,18],15:28,20:[2,18],21:36,22:[1,10],23:[1,11],24:[1,12],25:[1,13]},{5:[2,20],7:[2,20],13:[2,20],20:[2,20],22:[2,20],23:[2,20],24:[2,20],25:[2,20]},{5:[2,22],7:[2,22],13:[2,22],16:[1,37],17:[1,38],20:[2,22],22:[2,22],23:[2,22],24:[2,22],25:[2,22]},{10:[2,9],13:[2,9],14:18,15:9,22:[1,10],23:[1,11],24:[1,12],25:[1,13]},{10:[2,13],13:[2,13],17:[1,39],22:[2,13],23:[2,13],24:[2,13],25:[2,13]},{10:[2,14],13:[2,14],22:[2,14],23:[2,14],24:[2,14],25:[2,14]},{5:[2,29],7:[2,29],10:[2,29],13:[2,29],16:[2,29],17:[2,29],20:[2,29],22:[2,29],23:[2,29],24:[2,29],25:[2,29],27:[2,29]},{22:[2,32],23:[2,32],24:[2,32],25:[2,32],27:[2,32]},{15:28,18:40,19:26,21:27,22:[1,10],23:[1,11],24:[1,12],25:[1,13]},{15:28,19:41,21:27,22:[1,10],23:[1,11],24:[1,12],25:[1,13]},{5:[2,21],7:[2,21],13:[2,21],20:[2,21],22:[2,21],23:[2,21],24:[2,21],25:[2,21]},{15:42,22:[1,10],23:[1,11],24:[1,12],25:[1,13]},{15:43,22:[1,10],23:[1,11],24:[1,12],25:[1,13]},{15:44,22:[1,10],23:[1,11],24:[1,12],25:[1,13]},{5:[2,17],7:[2,17],13:[2,17],20:[1,35]},{5:[2,19],7:[2,19],13:[2,19],15:28,20:[2,19],21:36,22:[1,10],23:[1,11],24:[1,12],25:[1,13]},{5:[2,23],7:[2,23],13:[2,23],17:[1,45],20:[2,23],22:[2,23],23:[2,23],24:[2,23],25:[2,23]},{5:[2,24],7:[2,24],13:[2,24],20:[2,24],22:[2,24],23:[2,24],24:[2,24],25:[2,24]},{10:[2,15],13:[2,15],22:[2,15],23:[2,15],24:[2,15],25:[2,15]},{15:46,22:[1,10],23:[1,11],24:[1,12],25:[1,13]},{5:[2,25],7:[2,25],13:[2,25],20:[2,25],22:[2,25],23:[2,25],24:[2,25],25:[2,25]}],\ndefaultActions: {14:[2,2]},\nparseError: function parseError(str, hash) {\n    throw new Error(str);\n},\nparse: function parse(input) {\n    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = \"\", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    this.lexer.setInput(input);\n    this.lexer.yy = this.yy;\n    this.yy.lexer = this.lexer;\n    this.yy.parser = this;\n    if (typeof this.lexer.yylloc == \"undefined\")\n        this.lexer.yylloc = {};\n    var yyloc = this.lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = this.lexer.options && this.lexer.options.ranges;\n    if (typeof this.yy.parseError === \"function\")\n        this.parseError = this.yy.parseError;\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    function lex() {\n        var token;\n        token = self.lexer.lex() || 1;\n        if (typeof token !== \"number\") {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == \"undefined\") {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n        if (typeof action === \"undefined\" || !action.length || !action[0]) {\n            var errStr = \"\";\n            if (!recovering) {\n                expected = [];\n                for (p in table[state])\n                    if (this.terminals_[p] && p > 2) {\n                        expected.push(\"'\" + this.terminals_[p] + \"'\");\n                    }\n                if (this.lexer.showPosition) {\n                    errStr = \"Parse error on line \" + (yylineno + 1) + \":\\n\" + this.lexer.showPosition() + \"\\nExpecting \" + expected.join(\", \") + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\n                } else {\n                    errStr = \"Parse error on line \" + (yylineno + 1) + \": Unexpected \" + (symbol == 1?\"end of input\":\"'\" + (this.terminals_[symbol] || symbol) + \"'\");\n                }\n                this.parseError(errStr, {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});\n            }\n        }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error(\"Parse Error: multiple actions possible at state: \" + state + \", token: \" + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(this.lexer.yytext);\n            lstack.push(this.lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = this.lexer.yyleng;\n                yytext = this.lexer.yytext;\n                yylineno = this.lexer.yylineno;\n                yyloc = this.lexer.yylloc;\n                if (recovering > 0)\n                    recovering--;\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column};\n            if (ranges) {\n                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];\n            }\n            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n            if (typeof r !== \"undefined\") {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}\n};\nundefined/* Jison generated lexer */\nvar lexer = (function(){\nvar lexer = ({EOF:1,\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\nsetInput:function (input) {\n        this._input = input;\n        this._more = this._less = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};\n        if (this.options.ranges) this.yylloc.range = [0,0];\n        this.offset = 0;\n        return this;\n    },\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) this.yylloc.range[1]++;\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length-len-1);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length-1);\n        this.matched = this.matched.substr(0, this.matched.length-1);\n\n        if (lines.length-1) this.yylineno -= lines.length-1;\n        var r = this.yylloc.range;\n\n        this.yylloc = {first_line: this.yylloc.first_line,\n          last_line: this.yylineno+1,\n          first_column: this.yylloc.first_column,\n          last_column: lines ?\n              (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length:\n              this.yylloc.first_column - len\n          };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        return this;\n    },\nmore:function () {\n        this._more = true;\n        return this;\n    },\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\\n/g, \"\");\n    },\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c+\"^\";\n    },\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) this.done = true;\n\n        var token,\n            match,\n            tempMatch,\n            index,\n            col,\n            lines;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i=0;i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (!this.options.flex) break;\n            }\n        }\n        if (match) {\n            lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n            if (lines) this.yylineno += lines.length;\n            this.yylloc = {first_line: this.yylloc.last_line,\n                           last_line: this.yylineno+1,\n                           first_column: this.yylloc.last_column,\n                           last_column: lines ? lines[lines.length-1].length-lines[lines.length-1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length};\n            this.yytext += match[0];\n            this.match += match[0];\n            this.matches = match;\n            this.yyleng = this.yytext.length;\n            if (this.options.ranges) {\n                this.yylloc.range = [this.offset, this.offset += this.yyleng];\n            }\n            this._more = false;\n            this._input = this._input.slice(match[0].length);\n            this.matched += match[0];\n            token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);\n            if (this.done && this._input) this.done = false;\n            if (token) return token;\n            else return;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\\n'+this.showPosition(),\n                    {text: \"\", token: null, line: this.yylineno});\n        }\n    },\nlex:function lex() {\n        var r = this.next();\n        if (typeof r !== 'undefined') {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\npopState:function popState() {\n        return this.conditionStack.pop();\n    },\n_currentRules:function _currentRules() {\n        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;\n    },\ntopState:function () {\n        return this.conditionStack[this.conditionStack.length-2];\n    },\npushState:function begin(condition) {\n        this.begin(condition);\n    }});\nlexer.options = {};\nlexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\nvar YYSTATE=YY_START\nswitch($avoiding_name_collisions) {\ncase 0:/* skip whitespace */\nbreak;\ncase 1:return 23\nbreak;\ncase 2:return 24\nbreak;\ncase 3:return 22\nbreak;\ncase 4:return 'DBLQUOTE'\nbreak;\ncase 5:return '('\nbreak;\ncase 6:return ')'\nbreak;\ncase 7:return 25\nbreak;\ncase 8:return 27\nbreak;\ncase 9:return '^'\nbreak;\ncase 10:return 10\nbreak;\ncase 11:return 17\nbreak;\ncase 12:return 20\nbreak;\ncase 13:return 13\nbreak;\ncase 14:return 16\nbreak;\ncase 15:return 7\nbreak;\ncase 16:return 5\nbreak;\ncase 17:return 'INVALID'\nbreak;\n}\n};\nlexer.rules = [/^(?:\\s+)/,/^(?:[0-9]+)/,/^(?:\"(\\\\.|[^\\\\\"]*?)\")/,/^(?:[A-Za-z_][A-Za-z0-9_]*)/,/^(?:\")/,/^(?:\\()/,/^(?:\\))/,/^(?:\\[)/,/^(?:\\])/,/^(?:\\^)/,/^(?::)/,/^(?:@)/,/^(?:\\|)/,/^(?:,)/,/^(?:\\/)/,/^(?:;)/,/^(?:$)/,/^(?:.)/];\nlexer.conditions = {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17],\"inclusive\":true}};\nreturn lexer;})()\nparser.lexer = lexer;\nfunction Parser () { this.yy = {}; }Parser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = parser;\nexports.Parser = parser.Parser;\nexports.parse = function () { return parser.parse.apply(parser, arguments); }\nexports.main = function commonjsMain(args) {\n    if (!args[1])\n        throw new Error('Usage: '+args[0]+' FILE');\n    var source, cwd;\n    if (typeof process !== 'undefined') {\n        source = require('fs').readFileSync(require('path').resolve(args[1]), \"utf8\");\n    } else {\n        source = require(\"file\").path(require(\"file\").cwd()).join(args[1]).read({charset: \"utf-8\"});\n    }\n    return exports.parser.parse(source);\n}\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(typeof process !== 'undefined' ? process.argv.slice(1) : require(\"system\").args);\n}\n}","type":"commonjs"}],"ns":"genome-parser","mod_src":"/Users/eugene/github/DNA-workout/cs/lib/genome-parser"}}